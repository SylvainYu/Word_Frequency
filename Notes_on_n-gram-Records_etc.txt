n-gramRecords-Prediction.ipnb中读取数据以后，在Records_data.txt中写入经过处理的每个句子（一共5911个句子）。所谓“处理”，指的是去除非中文字符意外的元素，将无效字符都用空格替代；然后将句子jieba分词成为词语以后写入Records_data.txt中，仍旧按照每个句子的排列顺序，将单个句子涉及的词语在一行中罗列；这样也就有5911行。通过这样的处理，每个句子中有那些词语，它们的顺序也就保存下来。

=================
questions.txt内容：
施工单位现场漏做[MASK]。
资料检查未能发现[MASK]。
=================

2020-9-21-14:45时候测试失败。预测结果都显示“记录”。但基础数据来源是宝山监督站。

2020-9-21-14:48将questions.txt首句中“未见”变更成“漏做”，基础数据变更成邬嘉荪，再行测试。邬嘉荪监督记录供3753行。测试仍旧失败，因结果仍旧是两个“记录”。

2020-9-21-14:54questions.txt变更词语顺序，由“...漏做[MASK]。”变更成“...[MASK]漏做。”尝试。仍然失败，结果仍旧是两个“记录”。打算指定词语后，显示它附近那些文字出现概率最大。
其实，就是逐句琢磨predict()函数。---->看不大懂。

（1）打算尝试将整个监督记录内容都作为基础数据纳入，然后测试。（2）或者将测试数据扩大，在原版新闻数据测试中，它采用的questions.txt内容就比较多。（3）还得重新阅读博主原文，进一步加深理解。



=================
=================
=================
ngram-Records.ipnb模块中，
cell[37]“遍历所有预处理过的文件”注释下，
range()和zip()用法需要明确。后续还有collection模块的Counter()函数。
*****************************
Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。
通常与range()配套使用的Python3 list() 函数是对象迭代器，可以把range()返回的可迭代对象转为一个列表，返回的变量类型为列表。

zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。
通常我们可以使用 list() 转换来输出列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用*号操作符，可以将元组解压为列表。

collection模块的Counter()函数用于支持便捷和快速地计数。另，collection模块中也有Counter类，是dict子类，用于计数可哈希的对象。是一个无序的容器，元素被作为字典的key存储，其技术作为地点的value存储。
*****************************